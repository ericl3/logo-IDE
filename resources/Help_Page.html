<!DOCTYPE html>
<!-- saved from url=(0081)https://www2.cs.duke.edu/courses/compsci308/spring19/assign/03_slogo/commands.php -->
<html lang="en" class="gr__www2_cs_duke_edu"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   
  <meta name="author" content="Robert C. Duvall">
  <meta name="robots" content="all">
  <link href="./More_Commands_files/horizontal.css" type="text/css" rel="stylesheet" media="screen">
  <link href="./More_Commands_files/common.css" type="text/css" rel="stylesheet" media="screen">
  <link href="./More_Commands_files/compsci308.css" type="text/css" rel="stylesheet" media="screen">
  <link href="./More_Commands_files/print.css" type="text/css" rel="stylesheet" media="print">
 <link href="./Help_Page_files/horizontal.css" type="text/css" rel="stylesheet" media="screen">
 <link href="./Help_Page_files/common.css" type="text/css" rel="stylesheet" media="screen">
 <link href="./Help_Page_files/compsci308.css" type="text/css" rel="stylesheet" media="screen">
 <link href="./Help_Page_files/print.css" type="text/css" rel="stylesheet" media="print">
  <title>CompSci 308 : Spring 2019</title>
</head>

<body data-gr-c-s-loaded="true">

  <div class="mainBody">

<h3><a href="https://www2.cs.duke.edu/courses/compsci308/spring19/assign/03_slogo/index.php">SLogo</a> Command Help Page</h3>
<p>While the command names below are given in all capital letters, SLogo is not case sensitive and should accept any correct spelling of the command names.  Note that any values used as parameters to a command may be the result of calling any of the  commands below or a value stored in a variable. Thus all commands return a double value as described below. Also, commands can be formatted over any number of lines, including multiple commands on the same line, but each token is guaranteed to be separated by one or more spaces.</p>


<h4 align="left">Basic Syntax</h4>
<a name="Constant"></a><a name="Variable"></a><table border="1">
<tbody><tr>
  <th>Token</th>
  <th>Syntax</th>
  <th>Semantics</th>
  <th>Examples</th>
</tr>
<tr>
  <td><b>Constant</b></td>
  <td><div align="center"><code>-?[0-9]+\.?[0-9]*</code></div></td>
  <td>any real valued number<br>
      note, to avoid potential ambiguity in parsing there should not be a space between the negative sign and the value
  </td>
  <td><div align="right">
        <code>50</code><br>
        <code>-1.3</code>
      </div>
  </td>
</tr>
<tr>
  <td><b>Variable</b></td>
  <td><div align="center"><code>:[a-zA-Z_]+</code></div></td>
  <td>any word preceded by a colon, :<br>
    note, if a variable name is used that has not previously been given a value, return a default value (i.e., 0)</td>
  <td><div align="right">
    <code>:distance</code><br>
    <code>:side</code></div>
  </td>
</tr>
<tr>
  <td><b>Command</b></td>
  <td><div align="center"><code>[a-zA-Z_]+(\?)?</code></div></td>
  <td>any word can be a command-name<br>
    note, all commands return a numeric value<br>
    note, built-in commands are given below and  user-defined commands cannot reuse those names</td>
  <td><div align="right"> <code>forward</code><br>
    <code>fd</code></div></td>
</tr>
<tr>
  <td><strong>List</strong></td>
  <td><div align="center"><code>[ <br>
    ]</code></div></td>
  <td>these brackets enclose a list of zero or more commands or variables<br>
    note, to make parsing easier, these will always be separated from other tokens by spaces</td>
  <td><div align="right"><code>[ fd 50 rt 90 ]</code></div></td>
</tr>
<tr>
  <td><strong>Comment</strong></td>
  <td><div align="center"><code>^#.*</code></div></td>
  <td> Ignore any lines that are empty, i.e., only zero or more spaces, and lines that begin with the comment character, "#".</td>
  <td><div align="right"><code># a comment</code><br><code>#fd 50</code></div></td>
</tr>
</tbody></table>

<h4>Turtle Commands</h4>
<table border="1">
<tbody><tr>
  <th>Name(s)</th>
  <th>Description</th>
</tr>
<tr>
  <td>FORWARD <em>pixels</em><br>
    FD <em>pixels</em></td>
  <td>moves  turtle forward in its current heading by <em>pixels</em> distance<br>
    returns the value of <em>pixels</em></td>
</tr>
<tr>
  <td>BACK <em>pixels</em><br>
    BK <em>pixels</em></td>
  <td>moves  turtle backward in its current heading by <em>pixels</em> distance<br>
    returns the value of <em>pixels</em></td>
</tr>
<tr>
  <td>LEFT <em>degrees</em><br>
    LT <em>degrees</em></td>
  <td>turns  turtle counterclockwise by <em>degrees</em> angle<br>
    returns the value of <em>degrees</em></td>
</tr>
<tr>
  <td>RIGHT <em>degrees</em><br>
    RT <em>degrees</em></td>
  <td>turns  turtle clockwise by <em>degrees</em> angle<br>
    returns the value of <em>degrees</em></td>
</tr>
<tr>
  <td>SETHEADING <em>degrees</em><br>
    SETH <em>degrees</em></td>
  <td>turns  turtle to an absolute heading<br>
    returns number of degrees moved </td>
</tr>
<tr>
  <td>TOWARDS <em>x</em> <em>y </em></td>
  <td>turns  turtle to face the point (<em>x</em>, <em>y</em>), where (0, 0) is the center of the screen<br>
    returns the number of degrees  turtle turned</td>
</tr>
<tr>
  <td>SETXY <em>x</em> <em>y</em><br>
    GOTO <em>x</em> <em>y</em></td>
  <td>moves  turtle to an absolute screen position, where (0, 0) is the center of the screen<br>
    returns the distance turtle  moved </td>
</tr>
<tr>
  <td>PENDOWN<br>PD</td>
  <td>puts  pen down such that when the turtle moves, it leaves a trail<br>
    returns 1</td>
</tr>
<tr>
  <td>PENUP<br>PU</td>
  <td>puts  pen up such that when the turtle moves, it does not leave a trail<br>
    returns 0</td>
</tr>
<tr>
  <td>SHOWTURTLE<br>ST</td>
  <td>makes  turtle visible<br>
    returns 1</td>
</tr>
<tr>
  <td>HIDETURTLE<br>HT</td>
  <td>makes  turtle invisible<br>
    returns 0</td>
</tr>
<tr>
  <td>HOME</td>
  <td>moves  turtle to the center of the screen (0 0)<br>
    returns the distance turtle moved</td>
</tr>
<tr>
  <td>CLEARSCREEN<br>CS</td>
  <td>erases  turtle's trails and sends it to the home position<br>
    returns the distance turtle moved</td>
</tr>
</tbody></table>


<h4>Turtle Queries</h4>
<table border="1">
<tbody><tr>
  <th>Name</th>
  <th>Description</th>
</tr>
<tr>
  <td>XCOR</td>
  <td>returns the turtle's X coordinate  from the center of the screen</td>
</tr>
<tr>
  <td>YCOR</td>
  <td>returns the turtle's Y coordinate  from the center of the screen</td>
</tr>
<tr>
  <td>HEADING</td>
  <td>returns the turtle's heading in degrees</td>
</tr>
<tr>
  <td>PENDOWN?<br>
    PENDOWNP</td>
  <td>returns 1 if turtle's pen is down, 0 if it is up</td>
</tr>
<tr>
  <td>SHOWING?<br>
    SHOWINGP</td>
  <td>returns 1 if turtle is showing, 0 if it is hiding</td>
</tr>
</tbody></table>


<h4>Math Operations</h4>
<table border="1">
<tbody><tr>
  <th>Name</th>
  <th>Description</th>
</tr>
<tr>
  <td>SUM <em>expr1</em> <em>expr2</em><br>
    + <em>expr1</em> <em>expr2</em></td>
  <td>returns sum of the values of <i>expr1</i> and <i>expr2</i></td>
</tr>
<tr>
  <td>DIFFERENCE <em>expr1</em> <em>expr2</em><br>
    - <em>expr1</em> <em>expr2</em></td>
  <td>returns difference of the values of  <i>expr1</i> and <i>expr2</i></td>
</tr>
<tr>
  <td>PRODUCT <em>expr1</em> <em>expr2</em><br>
    * <em>expr1</em> <em>expr2</em></td>
  <td>returns product of the values of  <i></i> <i>expr1</i> and <i>expr2</i></td>
</tr>
<tr>
  <td>QUOTIENT <em>expr1</em> <em>expr2</em><br>
    / <em>expr1</em> <em>expr2</em></td>
  <td>returns  quotient of the values of  <i></i> <i>expr1</i> and <i>expr2</i></td>
</tr>
<tr>
  <td>REMAINDER <em>expr1</em> <em>expr2</em><br>
    % <em>expr1</em> <em>expr2</em></td>
  <td>returns  remainder on dividing the values of  <i></i> <i> expr1</i> by <i>expr2</i></td>
</tr>
<tr>
  <td>MINUS <em>expr</em><br>
    ~ <em>expr</em></td>
  <td>returns negative of the values of  <i></i> <i>expr</i></td>
</tr>
<tr>
  <td>RANDOM <em>max</em></td>
  <td>returns random non-negative number strictly less than <em>max</em></td>
</tr>
<tr>
  <td>
  SIN <em>degrees</em></td>
  <td>
  returns sine of <em>degrees</em></td>
</tr><tr>
</tr><tr>
  <td>
  COS <em>degrees</em></td>
  <td>
  return cosine of <em>degrees</em></td>
</tr><tr>
</tr><tr>
  <td>
  TAN <em>degrees</em></td>
  <td>
  returns tangent of <em>degrees</em></td>
</tr><tr>
</tr><tr>
  <td>
  ATAN <em>degrees</em></td>
  <td>
  returns arctangent of <em>degrees</em></td>
</tr>
<tr>
  <td>
  LOG <em>expr</em></td>
  <td>
  returns  natural log of  <em>expr</em></td>
</tr>
<tr>
  <td>
  POW <em>base exponent</em></td>
  <td>
  returns  <em>base</em> raised to the power of the <em>exponent</em></td>
</tr>
<tr>
  <td>PI</td>
  <td>Reports the number Pi</td>
</tr>
</tbody></table>


<h4>Boolean Operations</h4>
<table border="1">
<tbody><tr>
  <th>Name</th>
  <th>Description</th>
</tr>
<tr>
  <td>LESS? <em>expr1</em> <em>expr2</em><br>
    LESSP <em>expr1</em> <em>expr2</em></td>
  <td>returns 1  if the value of  <i></i> <em>expr1</em> is strictly less than the value of  <i></i> <em></em> <em>expr2</em>, otherwise 0</td>
</tr>
<tr>
  <td>GREATER? <em>expr1</em> <em>expr2</em><br>
    GREATERP <em>expr1</em> <em>expr2</em></td>
  <td>returns 1 if the value of  <i></i> <em></em> <em>expr1</em> is strictly greater than the value of  <i></i> <em></em> <em>expr2</em>,  otherwise 0</td>
</tr>
<tr>
  <td>EQUAL? <em>expr1</em> <em>expr2</em><br>
    EQUALP <em>expr1</em> <em>expr2</em></td>
  <td>returns 1 if the value of  <i></i> <em></em> <em>expr1 </em>and the value of  <i></i> <em></em> <em>expr2</em> are equal, otherwise 0</td>
</tr>
<tr>
  <td>NOTEQUAL? <em>expr1</em> <em>expr2</em><br>
    NOTEQUALP <em>expr1</em> <em>expr2</em> &nbsp;</td>
  <td>returns 1 if the value of  <i></i> <em></em> <em>expr1</em> and   the value of  <i></i> <em></em><em>expr2</em> are not equal, otherwise 0</td>
</tr>
<tr>
  <td>AND <em>test1</em> <em>test2</em></td>
  <td>returns 1  if <i>test1</i> and <i>test2</i> are non-zero, otherwise 0</td>
</tr>
<tr>
  <td>OR <em>test1</em> <em>test2</em></td>
  <td>returns 1 if <i>test1</i> or <i>test2</i> are non-zero, otherwise 0</td>
</tr>
<tr>
  <td>NOT <em>test</em></td>
  <td>returns 1 if <i>test</i> is 0 and 0 if <i>test</i> is non-zero</td>
</tr>
</tbody></table>


<h4>Variables,  Control Structures, and User-Defined Commands</h4>
<table border="1">
<tbody><tr>
  <th>Name</th>
  <th>Description</th>
</tr>
<tr>
  <td>MAKE <em>variable</em> <em>expr</em><br>
      SET <em>variable</em> <em>expr</em></td>
  <td>assigns the value of  <i></i> <em></em> <em>expr</em> to <em>variable</em>, creating the variable if necessary<em><br>
  </em>returns <em>expr</em></td>
</tr>
<tr>
  <td>REPEAT <em>expr</em> [ <em>command(s)</em> ]</td>
  <td>runs  <em>command(s</em>) given in the  list the value of  <i></i> <em></em> <em>expr</em> number of times<br>
    returns the value of the final command executed  (or 0 if no commands are executed)<br>    
    note, the value of the current iteration, starting at 1, is automatically assigned to the variable <em>:repcount</em> so that it can be accessed by the <em>command(s)</em></td>
</tr>
<tr>
  <td>DOTIMES [ <em>variable</em> <em>limit</em> ]<br>
    [ <em>command(s)</em> ]</td>
  <td>runs  <em>command(s)</em> for each value specified in the range, i.e., from (1 - <em>limit</em>) inclusive <br>
    returns the value of the final command executed  (or 0 if no commands are executed)<br>
    note, <em>variable</em> is assigned to each succeeding value so that it can be accessed by the <em>command(s)</em></td>
</tr>
<tr>
  <td>FOR [ <em>variable</em> <em>start end increment</em> ]<br>
    [ <em>command(s)</em> ]</td>
  <td>runs  <em>command(s)</em> for each value specified in the range, i.e., from (<var>start</var> - <em>end</em>), going by <em>increment</em><br>
    returns the value of the final command executed  (or 0 if no commands are executed)<br>
    note, <em>variable</em> is assigned to each succeeding value so that it can be accessed by the <em>command(s)</em></td>
</tr>
<tr>
  <td>IF <em>expr</em> [ <em>command(s)</em> ]</td>
  <td>if <em>expr</em> is not 0, runs the <em>command(s)</em> given in the  list<br>
    returns the value of the final command executed (or 0 if no commands are executed)</td>
</tr>
<tr>
  <td>IFELSE <em>expr</em> <br>
    [ <em>trueCommand(s)</em> ] <br>
    [ <em>falseCommand(s)</em> ]</td>
  <td>if <i> expr</i> is not 0, runs the <em>trueCommands</em> given in the first  list, otherwise runs the <em>falseCommands</em> given in the second  list<br>
    returns the value of the final command executed  (or 0 if no commands are executed)</td>
</tr>
<tr>
  <td>TO <em>commandName<br>
    </em> [ <em>variable(s)</em> ]<br>
    [ <em>command(s)</em> ]</td>
  <td>assigns <em>command(s)</em> given in the second list to <em>commandName</em> using <em>parameters</em> given in first list as variables<br>
    when <em>commandName</em> is used later in a program,  any given values are assigned to variables that can be accessed when  the command list is run and  the value of the final command executed is returned (or 0 if no commands are executed)<br>
    returns 1 if command is successfully defined, otherwise 0</td>
</tr>
</tbody></table>

  <h4>Display Commands</h4>
  <p>Note, for commands below that receive/return an index number, that index should refer to a list of  graphical items (like an image or color) whose items are clearly available in the GUI with their number or order apparent (so the user knows how to refer  to them within a command). Also, it would be helpful to populate each list with some initial default choices for the user.</p>

  <table border="1">
    <tbody><tr>
      <th>Command</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><code>SETBACKGROUND</code> <em>index</em><br>
        <code>SETBG</code> <em>index</em>
      </td>
      <td>sets background color of screen to that represented by <em>index</em><br>
        returns given <em>index</em></td>
    </tr>
    <tr>
      <td><code>SETPENCOLOR</code> <em>index</em><br>
        <code>SETPC</code> <em>index</em>
      </td>
      <td>sets color of the pen to that represented by <em>index</em><br>
        returns given <em>index</em></td>
    </tr>
    <tr>
      <td><code>SETPENSIZE</code> <em>pixels</em><br>
        <code>SETPS</code> <em>pixels</em>
      </td>
      <td>sets size of the pen to be <em>pixels</em> thickness<br>
        returns given <em>pixels</em></td>
    </tr>
    <tr>
      <td><code>SETSHAPE</code> <em>index</em><br>
        <code>SETSH</code> <em>index</em>
      </td>
      <td>sets shape of turtle to that represented by <em>index</em><br>
        returns given <em>index</em></td>
    </tr>
    <tr>
      <td><code>SETPALETTE</code> <em>index</em> <em>r</em> <em>g</em> <em>b</em></td>
      <td>sets color corresponding at given <em>index</em> to given <em>r</em> <em>g</em> <em>b</em> color values<br>
        returns given <em>index</em><br>
        note, color component values are nonnegative integers less than 256 specifying an amount of red, green, and blue </td>
    </tr>
    <tr>
      <td><code>PENCOLOR<br>
      </code><code>PC</code></td>
      <td>returns  turtle's current color index</td>
    </tr>
    <tr>
      <td><code>SHAPE</code><br>
        <code>SH</code><em></em></td>
      <td>returns   turtle's current shape index</td>
    </tr>
    </tbody></table>
  <h4>Multiple Turtle Commands</h4>
  <table border="1">
    <tbody><tr>
      <th>Command</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>ID</td>
      <td>returns  current active turtle's ID number<br>
        ID values typically start at 1 and increase by 1 with each new turtle created<br>
        note, there is  technically only one "active turtle" at any given time since each command is run once for each active turtle, i.e., this value can always be used to identify the current turtle running the command</td>
    </tr>
    <tr>
      <td>TURTLES<br>
        <br></td>
      <td>returns  number of turtles created so far</td>
    </tr>
    <tr>
      <td><code>TELL</code> <code>[</code> <em>turtle(s)</em> <code>]</code></td>
      <td>sets <em>turtles</em> that will follow commands hereafter<br>
        returns last value in <em>turtles</em> list<em><br>
        </em>note, if turtle has not previously existed, it is created and placed at the home location<br>
        note, if more than one turtle is active, commands run return value associated with the last active turtle </td>
    </tr>
    <tr>
      <td><code>ASK</code> <code>[</code> <em>turtle(s)</em> <code>]</code> <br>
        <code>[</code><em>&nbsp;&nbsp;command(s)</em> <code>]</code></td>
      <td>only the <i>turtles</i> given in first list all run <em>commands</em> given in the second list<em><br>
      </em>returns result of last command run by the last turtle<br>
        note, after commands are run,  currently active list of turtles returns to that set by the last TELL command (or default active turtle if TELL never given)<br>
        note, if more than one turtle is active, commands run return value associated with the last active turtle </td>
    </tr>
    <tr>
      <td><code>ASKWITH</code> <code>[</code> <em>condition</em> <code>]<br>
      </code> <code>[</code><em>&nbsp;&nbsp;command(s)</em> <code>]</code></td>
      <td>tell <i>turtles</i> matching  given <em>condition</em> to run <em>commands</em> given in the second list<em><br>
      </em>returns result of last command run<br>
        note, after commands are run,  currently active list of turtles returns to that set by the last TELL command (or default active turtle if TELL never given)<br>
        note, if more than one turtle is active, commands run return value associated with the last active turtle </td>
    </tr>
    </tbody></table>
  <h4>Additional Command Notes</h4>
  <h5>Multiple turtles</h5>
  <p>Since different versions of Logo handle multiple turtles differently your team will have some flexibility in how you choose to implement TELL/ASK. For example, these commands are the only way to make new turtles, so you may want to adopt the shorthand used by newer versions of Logo to create LOTS of turtles:</p>
  <blockquote>
    <pre>tell [ 100 ]</pre>
  </blockquote>
  <p>When the original Logo supported multiple turtles, this command simply created a second turtle (with IDs 1 and 100), but most modern versions simply create all the turtles up to that value (i.e., 99 additional turtles). Document your team's decision on how to handle this.</p>
  <p>Additionally,  your team will need to clarify  when the evaluation of command arguments occur because it affects the results with multiple turtles. Consider the following code examples:</p>
  <blockquote>
  <pre>set :x 10
tell [ 1 2 3 ]
# this command is only executed once
set :x * :x :x
# all turtles move the same distance
fd :x</pre>
    <pre>set :x 10
# team decision: do all turtles move the same distance or different?
# i.e., is the variable's value set once and passed to fd or evaluated each time FD is run
fd set :x + :x 10</pre>
    <pre>set :x 10
# all turtles definitely each move different distances
# since ID always returns the value of the current turtle running the command
fd * id :x</pre>
  </blockquote>
  <p>To be clear, using TELL/ASK is <em>not</em> the same as writing a loop, not all commands are run for each turtle — just the turtle commands. In the second example, if your team evaluates the arguments once and passes the values to the command, then it would make sense that the turtles all move the same distance. On the other hand, if the command evaluates its arguments, then it would make sense for the variable to be set multiple times. In short, please do not try to look at what the arguments to a&nbsp;command are to decide how many times to run&nbsp;it, your code will become a nightmare.</p>
  <p>Note, that the last command must return a different value for each turtle, since the "active" turtle changes each time FD is run. Thus, your ID command (and any turtle query command in general) should be smart enough to always return its own value no matter when the arguments are evaluated.</p>
  <p>Lastly, commands like SETPC and SETSH are not turtle specific and change their settings for all future commands for all turtles (until another one is called). So if you want it to be set differently for different turtles then you have to specifically change it for each turtle (i.e., in a loop) or set it to a value based on ID.</p>
  <h5>Unlimited parameters</h5>
  <p>It is sometimes more convenient for users to pass multiple parameters to one command than to compose multiple calls together to achieve the same affect. Thus, like Logo, add syntactic sugar to allow programmers to pass an unlimited number of parameters to commands.</p>
  <table border="1">
    <tbody><tr>
      <td>( <em>command</em> <em>expression(s)</em> )</td>
      <td>allows <em>command</em> to take any number of <em>expressions</em> as parameter values<br>
        note, this syntax is legal for any command, but make only make sense for some commands</td>
    </tr>
    </tbody></table>
  <p>For example, the following are equivalent:</p>
  <blockquote>
  <pre># ugly way to go FD 100
fd sum sum sum 10 20 30 40
# arguably cleaner way to go FD 100
fd ( sum 10 20 30 40 )
# goes FD four times (or you can combine the values and just go FD 100 once)
( fd 10 20 30 40 )</pre>
  </blockquote>
  <p>If the command already takes multiple arguments then it is just like calling the command multiple times and you will need to error check that you get a correct multiple of arguments and that they are always in the right order. For example:</p>
  <blockquote>
  <pre># move turtle around the screen
( setxy 10 20 300 400 0 100 )
# set multiple colors at once
( setpalette 10 255 0 0 11 0 255 0 12 0 0 255 )
# error, no last value for the variable
( set :x 100 :y 200 :z )
# legal, but really only the last one is relevant
( towards 100 100 20 10 )</pre>
  </blockquote>
  <p>Document your team's decision in your README on how to handle unlimited arguments for  situations you decide are ambiguous (and why you think they are).</p>
  <h5>Recursion</h5>
  <p>Recursion is tricky because it requires the parser to recognize the command being  defined (and its parameter count) as valid syntax before the command's own parsing is complete. If your parser can accommodate this, then you do not need the DEFINE command described below; however, it may be useful to use it to help get around this problem. Document your team's decision on this (and what happens if the user never decides to implement the defined command but calls it later and how it is displayed in the workspace).</p>

  <table border="1">
    <tbody><tr>
      <td><code>DEFINE <em>commandName<br>
      </em> [ <em>parameter(s)</em> ]</code><code></code></td>
      <td>defines  <em>command</em><em>Name</em> as a command that WILL BE created in the future, but has not yet been<br>
        returns 1 if command is successfully defined, otherwise 0</td>
    </tr>
    </tbody></table>

  </div>

</div>
  </div>



</body></html>